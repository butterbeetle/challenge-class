# 1. React Hooks (전부 리렌더링과 연관)

**Render는 화면을 그리기 전 단계에서 DOM 트리 자체를 만드는 과정**

### 01. useState

- 컴포넌트 내에서 변경 가능한 값이 필요, 그 값에 따라 화면이 다시 그려져야할 때 사용

### 02. useEffetct

- 컴포넌트의 생애 주기 또는 데이터의 생애 주기에 따라 **특정 코드**를 사용하고 싶을 때 사용
- 화면이 실제로 업데이트 된 이후에 비동기적으로 실행 되는 특징
  <br/>
- 반드시 화면을 그리는 과정이 1번 있다.
- 때문에 첫 화면과 두번째 화면은 다름
- 그래서 이걸로 바꾸는게 있으면 깜빡임이 있는거임
  <br/>
- mount - update -unmount 는 크게 나눈거고
- 세부적인 작업이 또 따로 있다 이말이야.
- 버츄얼 돔을 이전 돔과 비교하는 과정이있고 이걸 바탕으로
- 실제 DOM을 업데이트 하는 과정이있고 이걸 바탕으로
- 화면을 그리는 과정이있고
- 그 다음 useEffect임
- 소멸할때도 화면에 그리고 소멸함

### 03. useLayoutEffect

- 컴포넌트의 생애 주기 또는 데이터의 생애 주기에 따라 **특정 코드**를 사용하고 싶을 때 사용
- 화면이 실제로 업데이트 되기 이전에 동기적으로 실행 되는 특징
- 무거운 작업하면 작업 완료될 때 까지 화면이 그려지지않음
  <br/>
- 언마운트할때 그리기전이라 그런지 dom에 남아있음
  <br/>
- 화면에 그리지는 않았지만 DOM에는 이미 높이,넓이,위치 이런 값이 다 들어있다.
- 최초 그려지기 전에 이걸 쓴다 외엔 다 useEffect를 사용한다.

### 04. useMemo

- 컴포넌트의 생애 주기 또는 데이터의 생애 주기에 따라서 **특정 값**을 업데이트 하고 싶을 때 사용
- 시그니처, useEffect랑 useCallback 이랑 다 같음
- 첫번째 인자 callback 함수, 두번째 인자 의존성 배열
  - 의존성 배열에 아무것도 넣지 않으면 컴포넌트의 생애 주기를 따름
- 값을 저장하는것이 아님(잘못 이해한거)

### 05. useCallback

- 컴포넌트의 생애 주기 또는 데이터의 생애 주기에 따라 **특정 함수**를 새로 정의하고 싶을 때 사용

```javascript
const func = useCallback(() => {
  return count + 1;
}, [count]);
```

- count가 변화하지 않으면 리렌더링 되더라도 함수의 주소(참조값)이 유지됨

#### [참고] 어떤 때에 useMemo와 useCallback을 사용하는가?

1.  정말로 컴포넌트의 생애주기 또는 데이터 값의 변화에 따라 어떤 값을 업데이트 하고 싶을 때
2.  리렌더링 될 때마다 새롭게 값을 계산하거나 새롭게 함수를 정의하는 것이 문제가 될 때
    - a. 새로운 값의 계산이나 새로운 함수의 정의가 무거운 작업일 때(복잡할 때)
    - b. 값 또는 함수의 참조값을 유지하는 것이 중요할 때

### 06. useRef

- 컴포넌트의 리렌더링에 영향을 받지 않는 참조를 유지하고 싶을 때 사용
- 리렌더링과 무관하게 값을 유지해야 할 때가 있음.

```javascript
const 객체 = React.createElement();
```

- DOM Ref가 변경되지 않아서 문제가 없나? 아니면 새로 담아주기 때문에 문제가 없나?
  - 변경될 때 마다 새로 담아주기 때문에 문제가 없다.
- 달라지는건 버츌얼돔 기준으로 객체가 달라지는거지
- 다시 전달해주는 값은 같은 값임.

### 07. useId

- 유니크한 id값을 돌려주는 함수
- 컴포넌트 안에서 어떤 DOM(JSX)의 id값을 사용해야할 때
- 일반적으로 input에서 label과 같이 씀

# 2. Memoization

2. 부모가 준 Props가 변경 될 때

   - 상태 변경되면 함수가 재 실행되고 student의 메모리값이 변경되어서 student가 리렌더링댐
   - 이 억울함을 해결해주는게 useMemo라 이마리야

3. 부모가 리렌더링 되는 경우 자식도 리렌더링 되는게 억울해서 React.memo()를 씀
   - React.memo를 독립적으로 사용하는 경우가 많지는 않음

# 3. API

데이터를 가져온다

- 통신을 한다
- HTTP 프로토콜
- 요청 / 응답
- 요청을 하는 주체(클라이언트)
  - Request HTTP를 서버에게 보내고
- 응답을 하는 주체(서버)
  - Response HTTP를 클라이언트에게 보내고
  - 요청에 응답을 만들어 보내주면 끝

요청에 필요한 정보

- 서버의 주소:ip주소
- "https://www.api.com/products"
  이 주소 하나가 하나의 요청에만 대응하기 어려움
  - HTTP Method
    - GET
    - POST
    - PUT
    - DELETE
    - PATCH
    - HEAD
    - OPTIONS
  - 위 메서드를 CRUD에 대응하게 끔 API를 구성하는 것
  - 리소스의 위치 정보를 그대로 url 패스로 구성하는 것
    - RESTful API
  - GET방식 요청을 읽기(READ)에다가 연결하는 것
  - GET "https://www.api.com/posts/100/comments/30" 여기 정보를 읽겠다
  - POST "https://www.api.com/posts/100/comments/30" 여기에 하나 추가하겠다
  - PUT "https://www.api.com/posts/100/comments/30" 여기에 업데이트 하겠다
  - PATCH "https://www.api.com/posts/100/comments/30" 여기에 부분적으로 업데이트 하겠다
  - DELETE "https://www.api.com/posts/100/comments/30" 여기를 삭제하겠다

axios는 내장 기능이 아님.

- npm으로 설치해야 하는 별도의 라이브러리

# fetch vs axios

**컴포넌트는 UI를 그리는것에 책임이 있음**

1. fetch

   - 장점
     1. 설치를 안해도 된다. 내장함수다.
     2. 브라우저 지원
   - 단점:
     1. 외부 라이브러리들에 비해서 상대적으로 사용 편의성이 떨어진다.
   - 그럼 언제 쓸까?
     - 사용자의 기기가 구리거나, 인터넷 환경이 느릴거라 생각될 때
     - npm 패키지를 하나 만든다, 이 패키지는 가능한 다른 패키지에 의존적이지 않을 수록 좋다.

2. axios
   - 장점:
     1. fetch에 비해 사용 편의성이 높다.
     - baseURL을 설정할 수 있어서 반복적으로 host를 작성할 필요가 없다.
     - 인스턴스화 해서 사용할 수 있다.
     - 인터셉터를 사용할 수 있다.
     - 자동으로 JSON을 JS객체로 변환해 준다.
     - HTTP 메서드 이름과 대응하는 인스턴스 메서드를 그대로 가지고 있다.
   - 단점:
     1. 별도 설치 필요
     2. 프로젝트의 용량이 커진다. 사용자의 인터넷 환경이 느릴 경우 영향을 줄 수 있다.
