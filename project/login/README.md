css 파일
import 하면 보이지 않는곳에 있는 웹팩(번들링도구)에서 css import를 만나면
loader를 가지고 처리를 따로해서 index.html에 넣어줌

scss 파일
css를 확장해서 사용할 수 있게 도와줌
styled component에서는 이 문법을 지원함

css module
반드시 파일명.module.css 로 써야함
scss 문법도 지원함
css나 scss랑 import하는 방식이 조금 다름
브라우저에서 보면 클래스이름이 이상함
왜냐? 컴포넌트가 많아질 때 클래스 이름 겹치는걸 방지하기 위해서
이것도 웹팩이란 녀석이 해주고있음
웹팩 설정이 엄청 복잡한데 요즘은 할 필요가 없다

CSS IN JS
emotion, styled-components 2개 있는데 차이가 없어서 쓰고싶은거 쓰면 댐(styled-components가 원조?)
동적인 스타일링을 위해서 사용
보통 css, scss 파일안에서는 비즈니스 로직을 사용하기 어렵다.
그래서 js안에 css를 넣어보자 해서 만들어짐

tailwind CSS (비슷한 bootstrap)
bootstrap보다 진보된게 tailwind css임
빌드 타임에 동적으로 사용된 클래스들만 모아서 동적으로 만들어줌

Redux
전역 상태 관리 - Global State Management

1. Props Drilling - 원시적인 방법
   극복하기 위해 나온 첫번째 라이브러리가 Redux
2. 라이브러리(Redux, Zustand, Recoil, React Query 등)
   2-1. 복잡하기 때문에 러닝커브가 있다.
   2-2. 간단한 상태관리를 위해서도 처음 작성해야하는 코드의 양이 많다.

- 단점 극복을 위한 노력
- 1.  Recoil, Zustand : 복잡함을 극복하기 위해 쉽게 사용할 수 있도록 개선, 개량하기 위해 등장
- 2.  React Query : 클라이언트 상태관리에서 비동기 통신 작업이 쉽지 않고(작성해야 할 코드의 양이 많음)
      서버 상태와 실시간 동기화가 어렵다는 단점을 개선, 개량하기 위해 등장

3. Context API - React 내부 기능 (Redux -> Context API -> zustand,Query 순으로 등장)

- 리액트 라이브러리 만으로도 전역 상태관리가 가능하도록 추가된 API

Redux 특징

1.  단방향 데이터 흐름(flux 아키텍처)
2.  의도된 복잡함(까다로움) -> 데이터를 엄격하게 변경하기 위해(Predictable and maintainable) 까다로운 구조
3.  배우기 조금 까다로움

- 개념과 용어가 조금 많음
- 기본적으로 작성해야 하는 코드의 양이 많음

Redux 핵심 개념

1.  Redux는 상태를 저장하고 불러오고 변화시킬 수 있는 곳이다.
2.  따라서 저장소가있고, 저장소 내 값에 대한 CRUD가 전부이다.
3.  저장소는 Store, 저장소 내 값에 대한 CUD처리는 Reducer가 한다.

- R은 useSelector가 한다.

Store(저장소) - 가장 중요한 곳

1.  상태가 저장되는 곳
2.  앱 전체에 걸쳐 단 하나만 생성하여 사용하는 것이 일반적
3.  저장소 내 공간은 리듀서 단위로 구분하는 것이 일반적

Reducer(리듀서)

1.  저장소에 있는 상태를 변경하는 함수

Redux 마스터를 위한 스토리텔링

1.  우리가 Redux통해 하는 것은 결국 store(저장소)의 값(state,상태)에 대한 읽고(R) 쓰기(CUD)가 전부
2.  이 중 읽기(R)은 너무나도 쉽다. useSelector라는 훅을 사용하면 모든 게 끝.
3.  하지만 쓰기(CUD)가 많이 까다롭다.
4.  지금부터 Reducer를 일종의 공장이라고 생각. store에 있는 값을 뚝딱뚝딱 변경하는 일을 하는 공장.
5.  이 공장(Reducer)가 까다롭다.
6.  아무렇게나 요청하면 작업을 안해준다.
7.  반드시 작업 명세서(action)를 전달해 줘야지만 그 내용대로 작업을 해 준다.

- 작업명세서에는 두 가지 정보가 필요하다.
  1.  작업의 종류(필수 정보) - action.type
  2.  작업을 할 때 필요한 정보(선택적 정보) - action.payload

8.  작업명세서는 작업을 요청하는 곳에서 작성한다. 즉 컴포넌트에서 작성한다.
9.  작업명세서를 작성한다고 작업이 되는 것이 아니다. 작업 명세서를 공장에 전달해 주어야 한다.

- 컴포넌트는 우체부(dispatch)를 통해 작업명세서를 공장에 보내고, 공장은 이를 받아 처리한다.

10. 작업 명세서를 매번 직접 쓰는 것은 비효율적이고 휴먼에러의 가능성이 있으므로 작업명세서를 찍어내는 도구(Action Creator)를 만든다.
